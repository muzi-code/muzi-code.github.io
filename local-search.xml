<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>HashMap JDK1.8</title>
    <link href="/2019/10/10/JUC-HashMap/"/>
    <url>/2019/10/10/JUC-HashMap/</url>
    
    <content type="html"><![CDATA[<h1 id="一、数据结构"><a href="#一、数据结构" class="headerlink" title="一、数据结构"></a>一、数据结构</h1><p><img src="https://github.com/muzi-code/image-collection/blob/main/java/juc/hashmap/HashMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84JDK1.8.jpg?raw=true" alt="案例图"></p><p>HashMap是java的util包中一个高效的查询容器，内部是类似哈希表的数据结构，哈希表以键值对为基础存储和查询数据，它的查询效率是O(1)。</p><p><strong>数据结构</strong></p><ul><li>数组：基于数组下标随机访问，查询速度快。</li><li>链表：通过链地址法解决Hash冲突。</li><li>红黑树：使用红黑树logn(n指的是链上的数量)级别的查询效率，解决链表过长查询效率低的问题。</li></ul><h2 id="1-数组"><a href="#1-数组" class="headerlink" title="1. 数组"></a>1. 数组</h2><p><strong>哈希表数组</strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">transient <span class="hljs-keyword">Node</span><span class="hljs-title">&lt;K</span>,V&gt;[] table;<br></code></pre></td></tr></table></figure><p><strong>描述</strong><br>HashMap实际存储键值数据的是名为talbe的字段，table是Node结点类型的数组。</p><h2 id="2-链表"><a href="#2-链表" class="headerlink" title="2. 链表"></a>2. 链表</h2><p><strong>哈希表元素的数据结构</strong></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> hash;<br>        <span class="hljs-keyword">final</span> K key;<br>        V value;<br>        Node&lt;K,V&gt; <span class="hljs-keyword">next</span>;<br>        <span class="hljs-comment">// ... ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>描述</strong><br>每一个结点都有一个hash、key、value和next，结点是构成单链表的基础数据结构。</p><h2 id="3-红黑树"><a href="#3-红黑树" class="headerlink" title="3. 红黑树"></a>3. 红黑树</h2><p><strong>哈希表树结点的数据结构</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala">static <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode&lt;K</span>,<span class="hljs-title">V&gt;</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LinkedHashMap</span>.<span class="hljs-title">Entry&lt;K</span>,<span class="hljs-title">V&gt;</span> </span>&#123;<br>        <span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; parent;  <span class="hljs-comment">// red-black tree links</span><br>        <span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; left;<br>        <span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; right;<br>        <span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; prev;    <span class="hljs-comment">// needed to unlink next upon deletion</span><br>        boolean red;<br>        <span class="hljs-comment">// ... ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>描述</strong><br>HashMap在1.8之后引入了红黑树的概念，红黑树是二叉搜索树的一种，常规的二叉搜索树只需要满足结点的值大于做孩子的值小于右孩子的值即可。但是红黑树不仅仅是这样，红黑树需要满足以下的性质。</p><h3 id="红黑树的性质"><a href="#红黑树的性质" class="headerlink" title="红黑树的性质"></a>红黑树的性质</h3><p>（来自算法导论第三版 p174）</p><ol><li>每个结点或是红色的，或是黑色的。</li><li>根结点是黑色的。</li><li>每个叶结点（NIL）是黑色的。</li><li>如果一个结点是红色的，则它的两个子结点都是黑色的。</li><li>对每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点。</li></ol><h3 id="为什么使用红黑树？"><a href="#为什么使用红黑树？" class="headerlink" title="为什么使用红黑树？"></a>为什么使用红黑树？</h3><p><strong>二叉搜索树</strong><br>传统的二叉搜索树最坏的情况下树的高度等于结点的数目，以至于查询数据达到了O(n)。</p><p><strong>AVL树</strong><br>平衡二叉树是一种平衡了树高的结构，使得任意一个结点的左右子树高差值不超过1。虽然AVL树可以弥补传统的二叉搜索树的缺点，但是它又引来了新的问题，当数据量大了的时候维护AVL树性质的自旋操作会很影响插入性能。</p><p><strong>红黑树</strong><br>通过红黑节点性质来维护树的结构，通过节点的颜色变换，简单的旋转赋值提高红黑树的插入性能。</p><p>红黑树的最长路径不会超过最短路径的两倍，此时全黑10 + 黑10红9，不会超过两倍。<strong>max &lt;= 2*min</strong></p><p><strong>数据结构小结</strong><br>红黑树的是许多“平衡搜索树”中的一种，它是一种似平衡的状态，它可以保证在最坏的情况下基本动态集合的操作时间复杂度为O(logn)。</p><h1 id="二、哈希寻址"><a href="#二、哈希寻址" class="headerlink" title="二、哈希寻址"></a>二、哈希寻址</h1><p><img src="https://github.com/muzi-code/image-collection/blob/main/java/juc/hashmap/HashMap%E5%93%88%E5%B8%8C%E5%AF%BB%E5%9D%80.jpg?raw=true" alt="案例图"></p><p><strong>寻址流程</strong></p><ol><li>使用key执行<strong>hash算法</strong>，用key的hashCode方法返回值当作<strong>扰动函数</strong>的基础数据，并计算最终哈希值。</li><li>根据返回的哈希值与表长减一的值进行<strong>与</strong>运算hash &amp; (n-1)，得到取模的结果。</li><li>把取模的结果当作目标下标进行相应的操作。</li></ol><p><strong>备注</strong><br>表达式[hash &amp; (n-1)] 和 [hash % n] 在表长为2的幂次的情况下，得到的结果是一致的，都可以作为取模操作。</p><h2 id="1-哈希算法"><a href="#1-哈希算法" class="headerlink" title="1. 哈希算法"></a>1. 哈希算法</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> hash(<span class="hljs-keyword">Object</span> <span class="hljs-built_in">key</span>) &#123;<br>    <span class="hljs-built_in">int</span> h;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">key</span> == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = <span class="hljs-built_in">key</span>.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>hash算法的目的是为了让不同的key哈希的结果更加离散，防止链表过长或红黑树过高。<br>上述HashMap的算法是基于键的hashCode返回值，参与到扰动函数的计算中，从而得到具体的哈希结果。这里需要注意当key为null的时候，返回的哈希值为0。</p><h2 id="2-扰动函数"><a href="#2-扰动函数" class="headerlink" title="2. 扰动函数"></a>2. 扰动函数</h2><p><img src="https://github.com/muzi-code/image-collection/blob/main/java/juc/hashmap/HashMap%E5%93%88%E5%B8%8C%E5%AF%BB%E5%9D%80%E6%89%B0%E5%8A%A8%E5%87%BD%E6%95%B0.jpg?raw=true" alt="案例图"></p><p>所谓的扰动函数是指，为了使得key尽可能的分散，我们需要使用到key的更多特征，而不仅仅是用其哈希值直接进行取模运算。上述扰动函数使用key哈希值和key哈希值无符号右移16位的值进行异或运算，引入了高16位的特征，增大哈希值的离散性。</p><h2 id="3-为什么异或更加分散？"><a href="#3-为什么异或更加分散？" class="headerlink" title="3. 为什么异或更加分散？"></a>3. 为什么异或更加分散？</h2><p><img src="https://github.com/muzi-code/image-collection/blob/main/java/juc/hashmap/HashMap%E6%89%B0%E5%8A%A8%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E5%BC%82%E6%88%96%E7%9A%84%E4%BB%B7%E5%80%BC.jpg?raw=true" alt="案例图"></p><p>与操作和或操作对位上0和1的概率是不均衡的，而异或是均衡的。哈希值右移16位，正好是32位的一半，高16位和低16位异或，混合了原始哈希值的高低位的特征，以此来加大低位的随机性。</p><h1 id="三、关键方法"><a href="#三、关键方法" class="headerlink" title="三、关键方法"></a>三、关键方法</h1><h2 id="1-保存结点"><a href="#1-保存结点" class="headerlink" title="1. 保存结点"></a>1. 保存结点</h2><p><img src="https://github.com/muzi-code/image-collection/blob/main/java/juc/hashmap/HashMap%E7%9A%84%E4%BF%9D%E5%AD%98%E6%B5%81%E7%A8%8B.png?raw=true" alt="案例图"></p><p><strong>put方法会先进行hash，然后调用putVal方法进行实际处理。</strong></p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">public V <span class="hljs-built_in">put</span>(K <span class="hljs-built_in">key</span>, V value) &#123;<br>    <span class="hljs-built_in">return</span> putVal(hash(<span class="hljs-built_in">key</span>), <span class="hljs-built_in">key</span>, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>putVal描述</strong></p><ol><li>如果当前表为空或长度为0，重新构建一个默认容量的容器。</li><li>如果哈希寻址到的下标的元素为空，创建一个Node放入。</li><li>非以上情况<br>i. 如果当前key等于待插入元素的key，hash值也相同，替换原值。<br>ii. 如果当前结点是treeNode，使用红黑树的putTreeVal方法插入结点。<br>iii. 否则就遍历当前链表依次比较key和hash，如果相同替换原值，不同就继续遍历，直到下一个结点是空的就插入。 插入会判断当前是否是第八个结点，是的话且表长等于64，链表就树化。</li><li>返回该key的原值，若没有则返回为空。</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">final V put<span class="hljs-constructor">Val(<span class="hljs-params">int</span> <span class="hljs-params">hash</span>, K <span class="hljs-params">key</span>, V <span class="hljs-params">value</span>, <span class="hljs-params">boolean</span> <span class="hljs-params">onlyIfAbsent</span>,<span class="hljs-params">boolean</span> <span class="hljs-params">evict</span>)</span> &#123;<br>        Node&lt;K,V&gt;<span class="hljs-literal">[]</span> tab; Node&lt;K,V&gt; p; <span class="hljs-built_in">int</span> n, i;<br>        <span class="hljs-keyword">if</span> ((tab = table)<span class="hljs-operator"> == </span>null<span class="hljs-operator"> || </span>(n = tab.length)<span class="hljs-operator"> == </span><span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 哈希表为空初始化</span><br>            n = (tab = resize<span class="hljs-literal">()</span>).length;<br>        <span class="hljs-keyword">if</span> ((p = tab<span class="hljs-literal">[<span class="hljs-identifier">i</span> = (<span class="hljs-identifier">n</span> - <span class="hljs-number">1</span>) &amp; <span class="hljs-identifier">hash</span>]</span>)<span class="hljs-operator"> == </span>null)<br>            <span class="hljs-comment">// 索引位置为空，放入当前结点</span><br>            tab<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = <span class="hljs-keyword">new</span><span class="hljs-constructor">Node(<span class="hljs-params">hash</span>, <span class="hljs-params">key</span>, <span class="hljs-params">value</span>, <span class="hljs-params">null</span>)</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            Node&lt;K,V&gt; e; K k;<br>            <span class="hljs-keyword">if</span> (p.hash<span class="hljs-operator"> == </span>hash<span class="hljs-operator"> &amp;&amp;</span><br><span class="hljs-operator">                </span>((k = p.key)<span class="hljs-operator"> == </span>key<span class="hljs-operator"> || </span>(key != null<span class="hljs-operator"> &amp;&amp; </span>key.equals(k))))<br>                <span class="hljs-comment">// 键相同值替换，后面判断替换值</span><br>                e = p;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p instanceof TreeNode)<br>                <span class="hljs-comment">// 树结点，使用红黑树的插入方法</span><br>                e = ((TreeNode&lt;K,V&gt;)p).put<span class="hljs-constructor">TreeVal(<span class="hljs-params">this</span>, <span class="hljs-params">tab</span>, <span class="hljs-params">hash</span>, <span class="hljs-params">key</span>, <span class="hljs-params">value</span>)</span>;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 遍历链表</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                    <span class="hljs-keyword">if</span> ((e = p.next)<span class="hljs-operator"> == </span>null) &#123;<br>                        p.next = <span class="hljs-keyword">new</span><span class="hljs-constructor">Node(<span class="hljs-params">hash</span>, <span class="hljs-params">key</span>, <span class="hljs-params">value</span>, <span class="hljs-params">null</span>)</span>;<br>                        <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                            treeify<span class="hljs-constructor">Bin(<span class="hljs-params">tab</span>, <span class="hljs-params">hash</span>)</span>;<br>                        break;<br>                    &#125;<br>                    <span class="hljs-comment">// 相同的键则跳出循环，判断替换原值</span><br>                    <span class="hljs-keyword">if</span> (e.hash<span class="hljs-operator"> == </span>hash<span class="hljs-operator"> &amp;&amp;</span><br><span class="hljs-operator">                        </span>((k = e.key)<span class="hljs-operator"> == </span>key<span class="hljs-operator"> || </span>(key != null<span class="hljs-operator"> &amp;&amp; </span>key.equals(k))))<br>                        break;<br>                    p = e;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 替换原值</span><br>            <span class="hljs-keyword">if</span> (e != null) &#123; <span class="hljs-comment">// existing mapping for key</span><br>                V oldValue = e.value;<br>                <span class="hljs-keyword">if</span> (!onlyIfAbsent<span class="hljs-operator"> || </span>oldValue<span class="hljs-operator"> == </span>null)<br>                    e.value = value;<br>                after<span class="hljs-constructor">NodeAccess(<span class="hljs-params">e</span>)</span>;<br>                return oldValue;<br>            &#125;<br></code></pre></td></tr></table></figure><h2 id="2-查询结点"><a href="#2-查询结点" class="headerlink" title="2. 查询结点"></a>2. 查询结点</h2><p><strong>get方法会先hash然后getNode寻找值</strong></p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> V <span class="hljs-built_in">get</span>(<span class="hljs-keyword">Object</span> <span class="hljs-built_in">key</span>) &#123;<br>    Node&lt;K,V&gt; e;<br>    <span class="hljs-keyword">return</span> (e = getNode(hash(<span class="hljs-built_in">key</span>), <span class="hljs-built_in">key</span>)) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : e.value;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>getNode描述</strong></p><ol><li>根据hash与运算求得数组下标位置，并判断是否有值。</li><li>有值的话，则判断查询的key，是否等于first结点的key，等于则返回。</li><li>头结点不等于的话，判断是否是红黑树的结点，是红黑树的结点就走红黑树的查询逻辑。</li><li>不是红黑树的结点就遍历单链表查询。</li></ol><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs q">final Node&lt;K,V&gt; getNode(<span class="hljs-type">int</span> hash, Object <span class="hljs-built_in">key</span>) &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; <span class="hljs-built_in">first</span>, e; <span class="hljs-type">int</span> n; K k;<br>    if ((tab = table) != <span class="hljs-built_in">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        <br>        <span class="hljs-comment">// 找hash值对应到数组中的元素下标，判断下标位置是否为空</span><br>        (<span class="hljs-built_in">first</span> = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-built_in">null</span>) &#123;<br>        <br>        <span class="hljs-comment">// 判断头结点</span><br>        if (<span class="hljs-built_in">first</span>.hash == hash &amp;&amp; <br>            ((k = <span class="hljs-built_in">first</span>.<span class="hljs-built_in">key</span>) == <span class="hljs-built_in">key</span> || (<span class="hljs-built_in">key</span> != <span class="hljs-built_in">null</span> &amp;&amp; <span class="hljs-built_in">key</span>.equals(k))))<br>            return <span class="hljs-built_in">first</span>;<br>        if ((e = <span class="hljs-built_in">first</span>.<span class="hljs-built_in">next</span>) != <span class="hljs-built_in">null</span>) &#123;<br>        <br>        <span class="hljs-comment">// 判断是否是树结点</span><br>            if (<span class="hljs-built_in">first</span> instanceof TreeNode)<br>                return ((TreeNode&lt;K,V&gt;)<span class="hljs-built_in">first</span>).getTreeNode(hash, <span class="hljs-built_in">key</span>);<br>                <br>            <span class="hljs-comment">// 遍历单链表</span><br>            <span class="hljs-keyword">do</span> &#123;<br>                if (e.hash == hash &amp;&amp;<br>                    ((k = e.<span class="hljs-built_in">key</span>) == <span class="hljs-built_in">key</span> || (<span class="hljs-built_in">key</span> != <span class="hljs-built_in">null</span> &amp;&amp; <span class="hljs-built_in">key</span>.equals(k))))<br>                    return e;<br>            &#125; <span class="hljs-keyword">while</span> ((e = e.<span class="hljs-built_in">next</span>) != <span class="hljs-built_in">null</span>);<br>        &#125;<br>    &#125;<br>    return <span class="hljs-built_in">null</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="3-哈希表扩容"><a href="#3-哈希表扩容" class="headerlink" title="3. 哈希表扩容"></a>3. 哈希表扩容</h2><p>HashMap 的扩容在 put 操作中会触发扩容，主要是这个方法:</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs haxe">final Node&lt;K,V&gt;[] resize() &#123;<br>        Node&lt;K,V&gt;[] oldTab = table;<br>        <span class="hljs-comment">// ... ...</span><br> <span class="hljs-comment">// 定义新哈希表</span><br>        Node&lt;K,V&gt;[] <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span> = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-type">Node</span>[<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span>];<br>        table = <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>;<br>        <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 老哈希表内容复制到新的哈希表</span><br>            <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>                <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-comment">// ... ...</span><br>                    <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 当前链表拆成两个链表，原位置表loHead，新位置表hiHead。</span><br>                        Node&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;<br>                        Node&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;<br>                        Node&lt;K,V&gt; next;<br>                        <span class="hljs-keyword">do</span> &#123;<br>                            next = e.next;<br>                            <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                                <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>)<br>                                    loHead = e;<br>                                <span class="hljs-keyword">else</span><br>                                    loTail.next = e;<br>                                loTail = e;<br>                            &#125;<br>                            <span class="hljs-keyword">else</span> &#123;<br>                                <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)<br>                                    hiHead = e;<br>                                <span class="hljs-keyword">else</span><br>                                    hiTail.next = e;<br>                                hiTail = e;<br>                            &#125;<br>                        &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);<br>                        <span class="hljs-comment">// 原位置表lohead设置到新表的原位置上。</span><br>                        <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;<br>                            loTail.next = <span class="hljs-literal">null</span>;<br>                            <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>[j] = loHead;<br>                        &#125;<br>                        <span class="hljs-comment">// 新位置表hihead设置到新表的原位置+原表长的位置上。</span><br>                        <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;<br>                            hiTail.next = <span class="hljs-literal">null</span>;<br>                            <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>[j + oldCap] = hiHead;<br>                        &#125;<br>                    &#125;<br><span class="hljs-comment">// ... ...</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>HashMap一次扩容的过程:<br>1、取当前table的2倍作为新table的大小。<br>2、根据算出的新table的大小new出一个新的Entry数组来，名为newTab。<br>3、HashMap中的table指向newTable。<br>3、轮询原table的每一个位置，将每个位置上连接的Entry，算出在新table上的位置，并以链表形式连接。原table上的所有Entry全部轮询完毕之后，意味着原table上面的所有Entry已经移到了新的table上。</p><h3 id="扩容案例"><a href="#扩容案例" class="headerlink" title="扩容案例"></a>扩容案例</h3><p>扩容前：</p><p><img src="https://github.com/muzi-code/image-collection/blob/main/java/juc/hashmap/HashMap%E5%93%88%E5%B8%8C%E8%A1%A8%E6%89%A9%E5%AE%B9%E5%89%8D.jpg?raw=true" alt="案例图"></p><p>扩容后：<br><img src="https://github.com/muzi-code/image-collection/blob/main/java/juc/hashmap/HashMap%E5%93%88%E5%B8%8C%E8%A1%A8%E6%89%A9%E5%AE%B9%E5%90%8E.jpg?raw=true" alt="案例图"></p><h3 id="扩容后数组的定位"><a href="#扩容后数组的定位" class="headerlink" title="扩容后数组的定位"></a>扩容后数组的定位</h3><p><img src="https://github.com/muzi-code/image-collection/blob/main/java/juc/hashmap/HashMap%E6%89%A9%E5%AE%B9%E5%89%8D%E5%90%8E%E4%BD%8D%E7%BD%AE%E8%A7%84%E5%88%99.png?raw=true" alt="案例图"></p><p>如图可知，扩容前的Hash值[A - F]都在同一个链表上，扩容后则链表就会拆开[ABC]在4位置，[DEF]在20位置。扩容后原来的链表元素仅可能出现在两个位置，如果链表元素原来在 x 位置上，那么扩容后的两个点位就是 x 和 x + 16的位置上。</p><p>故上图原来都在一个链表上，那么扩容就是4和20两个位置。</p><h2 id="4-put和putIfAbsent区别"><a href="#4-put和putIfAbsent区别" class="headerlink" title="4. put和putIfAbsent区别"></a>4. put和putIfAbsent区别</h2><p><strong>put方法onlyIfAbsent传的是false</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public V put(K key, V value) &#123;<br>    return put<span class="hljs-constructor">Val(<span class="hljs-params">hash</span>(<span class="hljs-params">key</span>)</span>, key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br><br>final V put<span class="hljs-constructor">Val(<span class="hljs-params">int</span> <span class="hljs-params">hash</span>, K <span class="hljs-params">key</span>, V <span class="hljs-params">value</span>, <span class="hljs-params">boolean</span> <span class="hljs-params">onlyIfAbsent</span>,<span class="hljs-params">boolean</span> <span class="hljs-params">evict</span>)</span><br><br></code></pre></td></tr></table></figure><p><strong>putIfAbsent方法onlyIfAbsent传的是true</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public V put<span class="hljs-constructor">IfAbsent(K <span class="hljs-params">key</span>, V <span class="hljs-params">value</span>)</span> &#123;<br>    return put<span class="hljs-constructor">Val(<span class="hljs-params">hash</span>(<span class="hljs-params">key</span>)</span>, key, value, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>putVal的onlyIfAbsent参数是干嘛的</strong></p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stan"><span class="hljs-comment">// 键相同替换原值的逻辑</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">e</span> != null) &#123; <span class="hljs-comment">// existing mapping for key</span><br>    V oldValue = <span class="hljs-built_in">e</span>.value;<br>    <span class="hljs-comment">// 如果onlyIfAbsent是false则是替换原值的</span><br>    <span class="hljs-comment">// onlyIfAbsent是true则是不会替换原值的</span><br>    <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == null)<br>        <span class="hljs-built_in">e</span>.value = value;<br>    afterNodeAccess(<span class="hljs-built_in">e</span>);<br>    <span class="hljs-keyword">return</span> oldValue;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="putIfAbsent小结"><a href="#putIfAbsent小结" class="headerlink" title="putIfAbsent小结"></a>putIfAbsent小结</h3><p>onlyIfAbsent参数为false，则新值会替换原值并且返回原值。<br>onlyIfAbsent参数为true，则原值不变并且返回原值。</p><h1 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h1><h2 id="1-澄清HashMap链表的树化条件"><a href="#1-澄清HashMap链表的树化条件" class="headerlink" title="1. 澄清HashMap链表的树化条件"></a>1. 澄清HashMap链表的树化条件</h2><h3 id="条件1-链表已有8个节点，第9个节点插入链表时树化。"><a href="#条件1-链表已有8个节点，第9个节点插入链表时树化。" class="headerlink" title="条件1:链表已有8个节点，第9个节点插入链表时树化。"></a>条件1:链表已有8个节点，第9个节点插入链表时树化。</h3><h4 id="8个节点，未树化。"><a href="#8个节点，未树化。" class="headerlink" title="8个节点，未树化。"></a>8个节点，未树化。</h4><p><img src="https://github.com/muzi-code/image-collection/blob/main/java/juc/hashmap/HashMap%E9%95%BF64%E5%8D%95%E9%93%BE8%E6%9C%AA%E6%A0%91%E5%8C%96.jpg?raw=true" alt="案例图-未树化"></p><h4 id="9个节点，树化。"><a href="#9个节点，树化。" class="headerlink" title="9个节点，树化。"></a>9个节点，树化。</h4><p><img src="https://github.com/muzi-code/image-collection/blob/main/java/juc/hashmap/HashMap%E9%95%BF64%E5%8D%95%E4%BD%8D%E7%BD%AE%E7%AC%AC9%E4%B8%AA%E7%BB%93%E7%82%B9%E6%A0%91%E5%8C%96.jpg?raw=true" alt="案例图-树化"></p><h4 id="插入结点源码解析"><a href="#插入结点源码解析" class="headerlink" title="插入结点源码解析"></a>插入结点源码解析</h4><p>当前count值要大于等于 TREEIFY_THRESHOLD(8) - 1，计数器从0开始计数，到7刚好是8个结点。遍历时从第2个节点开始，故当前待插入节点是8 + 1，第九个节点进行树化。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 遍历单链表，判断相同，直到找到空值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>    <span class="hljs-comment">// 重点这里e是第2个节点。</span><br>        <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 待插入结点已插入</span><br>            p.next = newNode(hash, <span class="hljs-built_in">key</span>, value, <span class="hljs-keyword">null</span>);<br>            <span class="hljs-comment">// 树化条件1: 当前count值大于等于 8 - 1，当前待插入结点如果是第九个结点（[0-7]为8个，从第二个节点开始故加1，所以待插入是第九个节点）就树化。</span><br>            <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>)<br>                treeifyBin(tab, hash);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>            ((k = e.<span class="hljs-built_in">key</span>) == <span class="hljs-built_in">key</span> || (<span class="hljs-built_in">key</span> != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-built_in">key</span>.equals(k))))<br>            <span class="hljs-keyword">break</span>;<br>        p = e;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="条件2-表的长度大于或等于64"><a href="#条件2-表的长度大于或等于64" class="headerlink" title="条件2:表的长度大于或等于64"></a>条件2:表的长度大于或等于64</h3><h4 id="树化方法源码解析"><a href="#树化方法源码解析" class="headerlink" title="树化方法源码解析"></a>树化方法源码解析</h4><p><strong>treeifyBin(tab, hash)方法</strong><br>表的长度小于MIN_TREEIFY_CAPACITY(64)，就不进行树化操作，resize扩容即可。反之，表的长度大于或等于64，才可以进行链表树化的操作。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> treeifyBin(Node&lt;K,V&gt;[] tab, <span class="hljs-built_in">int</span> hash) &#123;<br>    <span class="hljs-built_in">int</span> n, <span class="hljs-keyword">index</span>; Node&lt;K,V&gt; e;<br>    <span class="hljs-comment">// 表长度小于 MIN_TREEIFY_CAPACITY 64，此时扩容即可不需要进行树化操作。</span><br>    <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)<br>        resize();<br>    <br>    <span class="hljs-comment">// 表长大于等于64，才需要进行树化操作</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = tab[<span class="hljs-keyword">index</span> = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) &#123;<br>        TreeNode&lt;K,V&gt; hd = <span class="hljs-literal">null</span>, tl = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">do</span> &#123;<br>            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="hljs-literal">null</span>);<br>            <span class="hljs-keyword">if</span> (tl == <span class="hljs-literal">null</span>)<br>                hd = p;<br>            <span class="hljs-keyword">else</span> &#123;<br>                p.prev = tl;<br>                tl.<span class="hljs-keyword">next</span> = p;<br>            &#125;<br>            tl = p;<br>        &#125; <span class="hljs-keyword">while</span> ((e = e.<span class="hljs-keyword">next</span>) != <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">if</span> ((tab[<span class="hljs-keyword">index</span>] = hd) != <span class="hljs-literal">null</span>)<br>            hd.treeify(tab);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-自定义类型作为HashMap的键，为什么要重写hashCode和equals方法？"><a href="#2-自定义类型作为HashMap的键，为什么要重写hashCode和equals方法？" class="headerlink" title="2.自定义类型作为HashMap的键，为什么要重写hashCode和equals方法？"></a>2.自定义类型作为HashMap的键，为什么要重写hashCode和equals方法？</h2><p>equals方法是比较两个对象是否相同的方法，Object基础实现是比较hashCode，也就是对象的地址。<br>我们自定义类型如果想当作HashMap的键是需要重写equals方法的，否则两个对象的属性值相同，但是却不是同一个对象，地址不相同导致最终结果不相等。如果作为键的对象没有重写equals，这肯定是有问题的。</p><p>hashCode方法，是唯一标识一个对象的方法，Object默认实现时返回对象的地址。<br><strong>HashCode重写时需要注意以下几点：</strong></p><ol><li>hashCode方法中不能包含equals方法中没有的字段。</li><li>String和其它包装类型已有的hashCode可以直接调用。</li><li>hash = 31 * hash + (field != null ? field.hashCode : 0)；可以应用于hashCode方法当中。因为任何数 n * 31都可以被JVM优化为 (n&lt;&lt;5)-n 这个表达式，移位和减法要比其它的操作快速的多。</li></ol><p><strong>《Effective Java》中提出了一种简单通用的hashCode算法：</strong></p><ol><li>初始化一个整型的变量，并为此变量富裕一个非零的常数值，如 int code = 13;</li><li>如果对象中有String或其它包装类型，则递归调用该属性的hashCode，如果属性为空则处理为0。</li></ol><p><strong>案例</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">@Override<br><span class="hljs-built_in">public</span> <span class="hljs-type">int</span> hashCode() &#123;<br>    <span class="hljs-type">int</span> hash = <span class="hljs-number">13</span>;<br>    hash = hash * <span class="hljs-number">31</span> + (<span class="hljs-type">name</span> != <span class="hljs-keyword">null</span> ? <span class="hljs-type">name</span>.hashCode() : <span class="hljs-number">0</span>);<br>    hash = hash * <span class="hljs-number">31</span> + (<span class="hljs-keyword">location</span> != <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">location</span>.hashCode() : <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> hash;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-HashMap和HashTable有哪些不同？"><a href="#3-HashMap和HashTable有哪些不同？" class="headerlink" title="3. HashMap和HashTable有哪些不同？"></a>3. HashMap和HashTable有哪些不同？</h2><ol><li><p>初始容量：HashMap是16，HashTable是11。</p></li><li><p>HashTable是线程安全的，HashMap是线程不安全的。HashTable在读写方法前使用了synchronized同步锁HashMap就没有这些安全机制，多线程环境下使用是有问题的。</p></li><li><p>HashTable没有树化的操作，就仅仅是数组加链表。HashMap由于被到处引用，为了避免Hash冲突导致链表过长的问题，就引入了红黑树树化操作。</p></li></ol><h3 id="3-1-为什么HashMap和HashTable容量规则不同？"><a href="#3-1-为什么HashMap和HashTable容量规则不同？" class="headerlink" title="3.1 为什么HashMap和HashTable容量规则不同？"></a>3.1 为什么HashMap和HashTable容量规则不同？</h3><p><img src="https://github.com/muzi-code/image-collection/blob/main/java/juc/hashmap/HashMap%E8%BF%9D%E8%83%8C%E9%99%A4%E6%B3%95%E6%95%A3%E5%88%97%E6%B3%95%E8%A7%84%E5%88%99.png?raw=true" alt="案例图-未树化"><br>HashMap为了效率违背了算法导论的推荐，所以是有弊端的，HashMap为了弥补这个弊端，就重写了hash算法，加入了高位特征的扰动函数。使得h(k)结果足够分散。</p><h3 id="3-2-HashMap红黑树可能出现的实际诱因？"><a href="#3-2-HashMap红黑树可能出现的实际诱因？" class="headerlink" title="3.2 HashMap红黑树可能出现的实际诱因？"></a>3.2 HashMap红黑树可能出现的实际诱因？</h3><p><strong>HashMap 1.7 导致的Tomcat的DoS问题</strong></p><p>URL：<a href="http://mail-archives.apache.org/mod_mbox/www-announce/201112.mbox/%3C4EFB9800.5010106@apache.org%3E">http://mail-archives.apache.org/mod_mbox/www-announce/201112.mbox/%3C4EFB9800.5010106@apache.org%3E</a></p><p>上面链接的页面是来自Tomcat邮件组的讨论。Tomcat参数是用HashMap存储的，故如果参数有5W个，并且有心人构造了hash冲突比较严重的参数，此时链表的长度很长，查询参数就占用了CPU很多资源，就可能出现Dos问题（DoS时CPU100%）。</p><h2 id="4-HashMap为什么链表超过8个结点会树化？"><a href="#4-HashMap为什么链表超过8个结点会树化？" class="headerlink" title="4. HashMap为什么链表超过8个结点会树化？"></a>4. HashMap为什么链表超过8个结点会树化？</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TREEIFY_THRESHOLD = <span class="hljs-number">8</span>;<br></code></pre></td></tr></table></figure><p><img src="https://github.com/muzi-code/image-collection/blob/main/java/juc/hashmap/HashMap%E6%B3%A8%E9%87%8A%E6%B3%8A%E6%9D%BE%E5%88%86%E5%B8%83.png?raw=true" alt="案例图-未树化"></p><p>上图是JDK1.8HashMap源码中提供的泊松分布的注释，泊松分布链表中出现8个元素的概率是极低的，所以出现红黑树概率很低。并且树化条件并不只是链表长度超过8，数组长度也要是64及以上才行。</p>]]></content>
    
    
    <categories>
      
      <category>JDK源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>容器</tag>
      
      <tag>HashMap</tag>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
